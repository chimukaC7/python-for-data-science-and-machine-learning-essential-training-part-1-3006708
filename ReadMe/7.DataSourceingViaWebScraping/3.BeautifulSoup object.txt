BeautifulSoup object
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Let's look at web scraping with Python. I'm about to show you how to scrape data from the internet. But before jumping in, let me give you a brief introduction to web scraping by explaining how it's useful. Imagine you're a small business owner and you've got a blog. You decide that you want to create a new resources page, and on that page you want to include every link from your blog. What would you do? Go through each page of the blog manually and pull all of the links? That would take forever. What you could do instead is use Python to automatically go through your blog for you and extract every link from every page. That way you could just copy and paste the links onto your new resource page and it would be a lot more efficient. I've seen environmental engineers who use Python to scrape web data from weather station pages in order to gather sufficient data for hydrology analysis. I've also seen Amazon vendors who scrape web data from competing Amazon vendor pages so that they can use that data to populate their product descriptions using a semi-automated approach. I've seen humanitarian volunteers scrape web data from a foreign country's census site so that the data could be used to quickly form a resource allocation plan. And last, but of course not least, without web scraping, there would be no generative AI. Scrape content in the form of copy and images is a baseline necessity of training generative AI models. Without the source data that's scraped from the web There would be no chatGPT, Midjourney and what have you. In other words, web scraping is useful for an almost unlimited number of applications. In the coding demo that's coming up, I'm going to teach you about objects in Beautiful Soup and how to work with them. Later in the course, I'm going to teach you to work with parse data, scrape a webpage, and save your results. There are four main object types in Beautiful Soup. Those are BeautifulSoup object, tag object, NavigableString object and common object. The BeautifulSoup object is a representation of the document you're scraping as a whole. It's easily navigable and searchable. Tag elements correspond to XML and HTML elements in an original document. You can navigate the reference data using tag attributes. A NavigableString object is to add a bit of text within tag. Beautiful Soup uses NavigableString class as a container for bits of text. And lastly, the comment object. The comment object is a type of NavigableString object that you can use for commenting your code. In the coding demonstration that's coming up, I'm going to teach you about these objects in Beautiful Soup and how to work with them. In this coding demonstration, I'm going to teach you about objects in Beautiful Soup and how to work with them. Later in the course, I'm going to teach you how to work with parse data, scrape a webpage, and save your results. Before getting started here, I just want to check to make sure that our version of Python is compatible with the demonstration we're about to do. So this notebook was written for Python 3.10 and let's just check the version we're running here. So we'll say import sys and then let's print sys version. So we'll say sys.version and run this. And it looks like we have version 3.10, so we're good to go. Now let's go ahead and import our Beautiful Soup into the Jupyter Notebook. So we'll say from bs4 import BeautifulSoup and run this. Great, so now we have Beautiful Soup to work with inside of our Jupyter Notebook. Now what I've done for this demonstration is I'm providing you an HTML document so you don't need to type all of this stuff out of course. And so your Jupyter Notebook is coming loaded with this HTML. And we're going to use it to begin exploring the different types of objects within Beautiful Soup. All you have to do with this is run the block. Scroll to the end and then run it. Let's start by looking at the Beautiful Soup constructor. By default, the constructor will attempt to detect what parser type you need based on the document object you pass. Let's pick a parser for our constructor instead. To do that, we'll simply call the Beautiful Soup constructor and we're going to pass in our_html_document. That's what we just created when we ran the block prior. And then for the second argument, we're going to tell Beautiful Soup exactly what type of parser we want it to use to parse our data. Since our data is html, we'll pass the html parser. So create a string that reads html.parser. Let's set this whole thing equal to our_soup_object. This will be our soup object. And then let's just print that out. So we'll say print and then print(our_soup_object). Run this. Okay, so this is the output. It's all of our HTML. By default, the Beautiful Soup object is a format of UTF eight, which can be sort of difficult to read because it doesn't have much formatting. One great way to make the output easier to read is to prettify the soup object. The prettify method will turn a Beautiful Soup parse tree into a nicely formatted unicode string with each HTML or XML tag on its own line. Let's print out the first 300 characters of our soup object. We'll call the print function and then we'll pass in our_soup_object and then we'll call the prettify method off of that. And we only want the first 300 characters, so we'll just select [0:300] and run this. Great, so that's actually a lot easier to read than the output we got earlier. If you look back up here, it was kind of a big blob and now at least we have some structure. Now let's look at tag objects. First, we'll create tag names. So let's create another Beautiful Soup object called soup_object. And to generate this object, we'll call the Beautiful Soup constructor. And let's just pass in a tag. So we'll create a string and we'll say that this is h1 attribute_1 equal to heading level one. So this is actually heading level one tag and we're saying that the attribute_1 = "Heading Level 1". And this heading should read >Future Trends for IoT in 2018<. And then we will close the </h1> tag. And lastly, I want to pass in our html parser. So we'll say html.parser. And let me check this index on this really quickly. Should be, okay. So now we have an h1 tag and it's got an attribute of heading level one and then it reads Future Trends for IoT in 2018. Now what we need to do is go ahead and create a tag variable. We'll call it say tag= soup_object.h1. This essentially tells Beautiful Soup that the tag's name is h1, a reference to the HTML we passed in. So let's go ahead and print this whole thing out. So to do that, we'll call the type function and we'll pass in our tag and hit run. And so what you can see here is that our soup_object.h1 is actually a tag. So we named it tag, but when we call the type function, it actually prints out here as a tag element. And so we do indeed have a tag. Now let's actually print out this tag and see what it looks like. To do that, we will call the print function and we'll pass in our tag. And as you can see, it returns a string that reads h1. And that makes sense, right? Now, let's see what happens when we call the tag name. Let's say tag.name, print this out. And of course it's also h1. So the name of our tag is actually h1. And if you wanted to replace the tag name h1 with heading one instead, you can do that. You would just set the tag.name and set that equal to heading one instead. Here I'll show you. tag.name = 'heading 1'. Print this out and you can see that we've actually changed the tag name. So instead of it reading h1 as it does up here, it actually reads heading 1. So that's how you change the name of a tag. Let's just also print this out really quick just for clarity sake. So we'll say tag.name and we get heading 1 and that's great, we changed the tag name. Now let's look at tag attributes. A tag can have any variety of attributes. You can access the tag's attributes by treating the tag like a dictionary. In our example, the tag's attribute is attribute_1. So let's just go ahead and create a soup object, soup_object and we'll set it equal to our BeautifulSoup constructor. And then let's just take the tag that we created above, I'm going to copy and paste it in. We need the quotes 'cause it should be a string. And then we're going to use the same parameter of html.parser. And then let's create a tag variable. So we'll say tag is equal to soup_object.h1 and then we'll print this whole thing out. So we have our tag and it's been printed out here. And imagine for example, if you select attribute_1 from the tag object, it returns to string that reads Heading Level 1. That is directly from the markup we passed into Beautiful Soup constructor. So let's just try this out. We'll say tag and then we'll select our attribute_1. Let's see what we get back. Okay, I missed a t here, attribute. Okay, so fix that and then run this. And cool, so that's called Heading Level 1. That's what prints out. To return a dictionary that contained all of the tag attributes you'd simply call the attrs method. So let's try that out here. We'll say tag.attrs. As you can see, this tag has only one attribute, so you only get back one key value pair. You can easily add an attribute to a tag by simply attaching an attribute labeled to a tag object. Let's try that now. So we'll say tag and then we'll select attribute_2 and we'll assign that a value of Heading Level 1, which will be a string object, Heading Level 1 and I'll put an asterisk here. Now I have a little typo. I got a dot that we don't need, so I'm going to remove that. And then let's call the attrs method off of that tag. Run this. And then let's just print the tag. So those attributes both appear as part of the h1 tag. Pretty interesting. We can actually delete an attribute from a tag object. You would just say del tag and then select the attribute you want to delete. So in this case, we'll delete attribute_2 and print this out again. And now you can see attribute_2 is missing. Very easy. Let's also go ahead and just delete attribute_1. I'm going to copy this and paste it. And then just go ahead and change out the one for two. Run both of these. Then let's call attrs. So we'll say tag.attrs and run this. And now you can see we've deleted all of the attributes and we get back an empty dictionary. Now I want to show you how to navigate a parse tree by using tags. To navigate a specific portion of the tree, you'd simply write the name of the tag you're interested in. First things first though, we're going to start by importing our HTML document. And this is the same document we used earlier in your Jupyter Notebook. It's coming preloaded. I'm just going to go back up to the top and I'm going to copy this code block and bring it down so we can reuse it. And let's create a soup object. We'll call it our_soup_object and we'll set that equal to the BeautifulSoup constructor and we'll pass in our_html_document and an argument that reads html.parser. Going to run this. Now to retrieve certain tags from within the parse tree, all you need to do is write the name of the tag. So if you want to pull up the title element from the HTML document, you would just say our_soup_object.head, so our_soup_object.head. And this returns the head tag that contains the document title. So as you can see here, the document title is IoT Articles. You can also achieve the same outcome by using the title tag. So let's just check that out. We'll say our_soup_object.title, run that and get the same thing, except that now we're missing the head tag, right? But we still get our article title. If you wanted to pull up this name of the article, well first let's look and see what part of the tree that's actually located in. So let's go back up to the top here. And it's held within the body tag, but there's a lot of other stuff in the body tag too. So to narrow and further we can specify that it's within the body tag of the b tag. So here's the first b tag. Go back down here and then just try and access the title that way. So we'll say our_soup_object.body.b and run this. Well as you can see, the title of the article is the same as what's been printed out. So we were able to access it using tags. Just to show you what we'd get if we were to write in the b element, I'll say our_soup_object.body. And then what we're getting here is the entire body of the HTML. It's a lot of text, and so it's not really that useful for isolating portions of that text. To retrieve only the tags that are associated with lists, you could say our_soup_object.li. And then you get only the tags that are associated with lists. And if you wanted to retrieve the first tag that contains a web link, you could say our_soup_object.a and run this, and then you would get our first link in the article, which is a bit.ly link. Now that we finished with tag objects, let's start looking at the NavigableStream object. We'll cover that in our next coding demonstration.


Sure, let's break down the key concepts from the “BeautifulSoup object” video to help you understand it better:

Key Concepts of BeautifulSoup Object
What is BeautifulSoup?

BeautifulSoup is a Python library used for web scraping purposes to pull data out of HTML and XML files. It creates a parse tree from page source code that can be used to extract data easily.

Main Object Types in BeautifulSoup:

BeautifulSoup Object: Represents the entire HTML or XML document. It's the starting point for parsing a document.

Tag Object: Corresponds to an HTML or XML element. You can navigate and manipulate these tags.

NavigableString Object: Contains text within a tag. It allows you to work with the text content of tags.

Comment Object: A special type of NavigableString used for comments in the code.