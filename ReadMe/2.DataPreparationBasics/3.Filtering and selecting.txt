Filtering and selecting
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Let's talk about filtering and selecting data with pandas. Next up, I'm about to show you how to filter and select data using plain indexing, data slicing, and arithmetic comparisons using Python and Pandas. In this demonstration, we're going to work with two libraries, NumPy and Pandas. And the first thing you need to do is just to make sure that you have your library installed in your environment. So let's really quickly run pip install pandas. And in order to execute any code inside of a Jupyter Notebook, you want to just hit Shift + Enter in order to run code. So that's what I did there. And okay, so we have installed Pandas. Now we want to import both NumPy and Pandas. So to do that we say import numpy as np, import pandas as pd, and then from pandas we want to make sure to import DataFrame. And then we have all of that. So we will run this, Shift + Enter. So what you actually do is importing these libraries into the IPython environment. Then the next step involves the creation of a DataFrame object, and we'll fill it with some numbers and then I'll show you how we can apply different functions on that DataFrame object. So let's call that object numbers_df and we'll set it equal to, and then we'll call the DataFrame constructor and we'll pass in the np.arrange function. And then we'll say we want to generate a series of numbers between zero and 90, but we want only every third number. So to do that, we say zero is the first number, 90 as the end. And then define that we want only every third number here. The next thing we need to do is to define a shape for this object. And so to do that, we will call the reshape method and we'll pass in the values of 10 and three. 10 is going to be the number of rows, and then three will be the number of columns. The next thing we need to do is to set an index for this DataFrame. So to do that we'll just say index and then we'll set it equal to a list. And then for each index, we just want to create a label. So we'll start with row one, then we'll go through and just create a label for each index value. And since we have 10 rows, we need 10 index values. So I'll go ahead and just copy in all of these labels. And then also, let's name the columns here. So we'll say columns equal to, and then create another list. And then we'll just call the columns, columns one through three. So column one, and then just finish this out. I'll copy it in. This is red here. So it looks like we probably have a syntax error. So you can see here I have one too many parentheses. So let me just delete that and then rerun it. Okay, that cleared out that error. So now let's print the numbers DataFrame object. In order to do that, we just need to say numbers_df and then run this. Okay, so great, now you can see we have a numbers DataFrame object, and each of the index values are labeled according to the labels we passed into the DataFrame constructor. So now let's take a look at indexing and slicing. Indexing means accessing items from a data structure like arrays, series or DataFrames. And there are three types of indexing. Simple indexing, Boolean indexing, and fancy indexing. Let's start first with simple indexing on a DataFrame. To do that, we can use the iloc indexer to access items within a DataFrame. One thing you need to know is that indexing starts from zero, which means that the first element is placed at the zero index. In a DataFrame, we have multiple rows and columns. So in order to access an item in a DataFrame, we need to pass its row and column number in square brackets separated by a comma. The value before the comma is the row number and the value after the comma is the column number. And if we want to access the second item in the first row of the DataFrame, then we would just call the numbers_df object. And then we would use the iloc method, and we will pass row number zero in column number one into this iloc indexer. And then when we run this, we get back the value of three. So if we look back up here, we can see that the value of three is sitting in the row that is of index value zero in the column which has an index value of one, 'cause again, indices start from zero, which means that the first element is placed at the zero index value. We can use the equal notation to replace a value in a DataFrame. To illustrate this better, let's replace the value at row one and column one with the number 20, and then run the code block. So we'll call the numbers, numbers underscore DataFrame object, the iloc method, and then we'll define the position here as zero and one. So the value at row zero in column one, and we'll set that equal to 20. And then we will, oops, I missed an S here. And then let's print out the object. So we'll say numbers underscore DataFrame and then run this. And you can see here now that what used to be value of three here has now been replaced with a value of 20. Now let's look at how fancy indexing works. Fancy indexing is like the simple indexing that we just used, but there's a difference. Instead of passing single scalers, we're going to pass arrays of indices. In the DataFrame we can retrieve common items between specific rows and columns using fancy indexing. So as an example, let's access the common items between the second, third and fifth row in the second and third column. So to do that, we call the numbers_df object and we call the iloc method. And then let's define the rows that we want to return, which would be one, two, and four, and also the columns, which is going to be columns at index position one and index position two. And then we run this. And now as you can see, we have returned the common items between the second, third and fifth row and the second and third column. Now let's dig into Boolean indexing in a DataFrame. Boolean indexing is done through comparison operators, and in case you are not quite sure what I mean by comparison operators, comparison operators are just like greater than, less than, equal than, basic arithmetic comparison operators. So we're going to look at comparison operators and masking. Comparison operators compare a single scaler value with all the values in the DataFrame, and they always return a DataFrame with Boolean values. Boolean values are also called a Boolean mask. Let's implement Boolean indexing on the DataFrame. So to do that, if we wanted to find values greater than 30 in the DataFrame, we could say mask equal to, and then call the numbers_df object and just say we want everything that's greater than the number 30. And then print out the mask and run that. That was marked down so we need to make sure that it is actually the correct code formatting here. So I'll turn that to Python code and then run that. And now you can see we have a DataFrame full of Boolean values where if the value is greater than 30, then the result is returned as true. And then if the value is less than 30, the result is returned as false. We can use this Boolean mask to retrieve a subset of data from the DataFrame. If we pass the Boolean mask in the DataFrame, it will return to us those values which were greater than 30. So we'll say numbers_df and then we just want to return the mask. And if we run this code block, we can see that only the values which are greater than 30 are returned. If the value is less than 30, then we get NAN, not a number. So if the values are less than 30, then we just get this NaN. So as you can see, this just returns all the values from the DataFrame that are greater than 30 as defined by our mask object. Boolean mask is also used to replace values in a DataFrame. So let's try that out really quickly. Here let's set all of the values in the DataFrame that are greater than 30 such that they are set equal to zero. To do that, we'll just call the numbers_df object, and then we want to return all of the numbers within the numbers DataFrame that are greater than 30, and we want to set those values equal to zero. And then we'll call the numbers_df object again. Run that, and you can see that all of the numbers from the DataFrame that were greater than 30 have now been set to zero. The last thing I wanted to show you here is how to slice values from the DataFrame. Slicing means pulling a section from the DataFrame. So we can slice values using the colon notation. Any value that we put before the colon is the starting index of the slice. And the value after the colon is the ending index of the slice. Let's slice the values from the third to the sixth row and the second to third column. To do that, we'll say numbers_df and then we'll call the iloc method. And then we'll say we want the rows in index position two through six and column index position one through three, and we can run this. And then as you can see, it has returned to us the values that are common between the third, fourth, fifth, and sixth row and the second and third column.


Absolutely, let's break down the key concepts from the “Filtering and selecting” video to make them easier to understand.

1. Importing Libraries:
What it means: Before you can start working with data in Python, you need to bring in some tools. These tools are called libraries, and for data work, NumPy and pandas are essential.
Analogy: Think of it like needing a hammer and nails before you can start building something.

2. Creating a DataFrame:
What it means: A DataFrame is a way to organize your data into a table that's easy to work with. You can think of it as a spreadsheet where you can store and manipulate your data.
Example: If you have a list of numbers (like ages of people), you can put them into a DataFrame to organize and analyze them better.

3. Indexing and Slicing:
What it means: This is about selecting specific parts of your data. Indexing is like pointing to a specific row and column in your spreadsheet and saying, “I want the data here.” Slicing is like drawing a box around a group of cells in your spreadsheet and saying, “I want all the data inside this box.”
Example: If you only want the ages of people from the 2nd to the 5th person in your list, you'd use slicing to select just that part of your DataFrame.

4. Boolean Indexing:
What it means: This is a fancy way of selecting data based on conditions. For example, you can select all ages greater than 18. It's called Boolean because your condition is either True or False.
Example: Imagine you have a list of ages, and you want to find out who is an adult (18 and older). You can use Boolean indexing to quickly see which ages meet that condition.

5. Fancy Indexing:
What it means: This is similar to regular indexing but allows you to select multiple, non-adjacent rows and columns. It's like saying, “I want the data from these specific places, no matter where they are in my DataFrame.”
Example: If you want to see the ages of the 1st, 3rd, and 5th people in your list, fancy indexing lets you pick out just those entries.

6. Replacing Values:
What it means: Sometimes, you might want to change the data in your DataFrame. For example, you might want to replace all ages over 100 with a different value because they might be errors.
Example: If someone's age is mistakenly entered as 150, you can replace it with a more reasonable number, like the average age of your dataset.

By breaking down these concepts, I hope it's clearer how you can manipulate and analyze your data using pandas in Python. It's all about organizing your data in a way that makes it easy to work with, then selecting and modifying it to fit your needs.

